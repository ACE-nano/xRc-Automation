import re
import keyboard
import math
import time
from simple_pid import PID
import numpy as np

pidTurn = PID(0.015, 0.0, 0.002, setpoint=180)
pidTurn.output_limits = (-1.0, 1.0)
pidX = PID(1, 1, 1, setpoint=0)
pidX.output_limits = (-1.0, 1.0)
pidY = PID(1, 1, 1, setpoint=0)
pidY.output_limits = (-1.0, 1.0)

HAngles = [180, 170, 162, 155, 147, 140, 132, 126, 120, 115, 110, 105, 100, 95, 90, 85, 80, 75, 70, 66, 62, 58, 54, 50, 47, 44, 41, 38, 36, 34, 32]

#Set up controller input values
#Everthing above RightY is binary, 0 and 1, corresponding to a button
#Everything below and including RightY is a fload between -1 and 1
RevIn = 0
InR = 0
InRPos = 0
InL = 0
InLPos = 0
Shoot = 0
ClimbD = 0
ClimbU = 0
HoodU = 0
HoodD = 0
BumperL = 0
BumperR = 0
Stop = 0
Restart = 0
RightY = 0
Turn = 0
YMov = 0
XMov = 0
ClimbBack = 0
ClimbForward = 0

while(True):

    #Opens text documents
    with open('myRobot.txt', 'r') as Robot:
        RNums = Robot.readlines()
        #print(RNums)

    with open('GameElements.txt', 'r') as Game:
        GNums = Game.readlines()

    Controls = open('Controls.txt', 'w')

    #Checks to see if there is anything in the list
    if(len(RNums) == 0 or len(GNums) == 0):
        Controls.write('a=' + str(RevIn) + '\nb=' + str(InR) + '\nx=' + str(InL) + '\ny=' + str(Shoot) + '\ndpad_left=' + str(ClimbD) + '\ndpad_right=' + str(ClimbU) + 
        '\ndpad_up=' + str(HoodU) + '\ndpad_down=' + str(HoodD) + '\nbumper_l=' + str(BumperL) + '\nbumper_r=' + str(BumperR) + '\nstop=' + str(Stop) + '\nrestart=' + str(Restart) + 
        '\nright_y='+str(RightY) + '\nright_x=' + str(Turn) + '\nleft_y=' + str(YMov) + '\nleft_x=' + str(XMov) + '\ntrigger_l=' + str(ClimbBack) + '\ntrigger_r=' + str(ClimbForward))
        continue

    #grabs robot position
    GPos = [float(GPos) for GPos in re.findall(r'-?\d+\.?\d*', RNums[2])]
    GRot = [float(GRot) for GRot in re.findall(r'-?\d+\.?\d*', RNums[3])]
    HPos = [0.0 ,0.0 ,0.0]
    HAngle = [float(HAngle) for HAngle in re.findall(r'-?\d+\.?\d*', RNums[43])]
    Balls = []
    Balls.append([float(Ball1) for Ball1 in re.findall(r'-?\d+\.?\d*', GNums[58])])
    Balls.append([float(Ball1) for Ball1 in re.findall(r'-?\d+\.?\d*', GNums[64])])
    Balls.append([float(Ball1) for Ball1 in re.findall(r'-?\d+\.?\d*', GNums[70])])
    Balls.append([float(Ball1) for Ball1 in re.findall(r'-?\d+\.?\d*', GNums[76])])
    Balls.append([float(Ball1) for Ball1 in re.findall(r'-?\d+\.?\d*', GNums[82])])
    Balls.append([float(Ball1) for Ball1 in re.findall(r'-?\d+\.?\d*', GNums[88])])
    Balls.append([float(Ball1) for Ball1 in re.findall(r'-?\d+\.?\d*', GNums[94])])
    Balls.append([float(Ball1) for Ball1 in re.findall(r'-?\d+\.?\d*', GNums[100])])
    Balls.append([float(Ball1) for Ball1 in re.findall(r'-?\d+\.?\d*', GNums[154])])
    Balls.append([float(Ball1) for Ball1 in re.findall(r'-?\d+\.?\d*', GNums[160])])
    Balls.append([float(Ball1) for Ball1 in re.findall(r'-?\d+\.?\d*', GNums[166])])

    #Finds closest ball
    Close = 100
    BallNum = 0
    for i in range(len(Balls)):
        Dis = math.hypot(GPos[0]-Balls[i][0], GPos[2]-Balls[i][2])
        if Dis < Close and Balls[i][1] < .25:
            Close = Dis
            BallNum = i
    RadianBallVal = math.atan2(GPos[0]-Balls[BallNum][0], GPos[2]-Balls[BallNum][2])
    BRot = math.degrees(RadianBallVal)
    if BRot < 0:
        BRot+=360
    print(Balls[BallNum][1])

    #Gets good rotation to hub
    RadianBotVal = math.atan2(GPos[0], GPos[2])
    HRot = math.degrees(RadianBotVal)
    HRot+=93
    if HRot < 0:
        HRot+=360
    

    #Gets distance from hub
    Dist = math.hypot(GPos[0],GPos[2])
    Dist = round(Dist, 1)
    HIndex = int((Dist-1.3)*10)
    
    #Makes hood angle usable
    HAngle = HAngle[0]
    if(HAngle >=270):
        HAngle = (HAngle-450)*-1
    elif(HAngle <= 90):
        HAngle = (HAngle-90)*-1

    #Sets inputs based on keyboard
    if(keyboard.is_pressed('w')):
        YMov = -1
    elif(keyboard.is_pressed('s')):
        YMov = 1
    else:
        YMov = 0

    if(keyboard.is_pressed('a')):
        XMov = -1
    elif(keyboard.is_pressed('d')):
        XMov = 1
    else:
        XMov = 0

    if(keyboard.is_pressed('j')):
        Turn = -1
    elif(keyboard.is_pressed('l')):
        Turn = 1
    else:
        Turn = 0

    if(keyboard.is_pressed(',')):
        RevIn = 1
    else:
        RevIn = 0

    if(keyboard.is_pressed('.')):
        InR = 1
        if(InRPos == 0):
            InRPos = 1
        else:
            InRPos = 0
    else:
        InR = 0

    if(keyboard.is_pressed('n')):
        InL = 1
        if(InLPos == 0):
            InLPos = 1
        else:
            InLPos = 0
    else:
        InL = 0

    if(keyboard.is_pressed('k')):
        if Dist <= 4.3:
            Shoot = 1
        else:
            GoToHub = 1
            Shoot = 0
    else:
        Shoot = 0

    if(keyboard.is_pressed('z')):
        ClimbD = 1
    else:
        ClimbD = 0

    if(keyboard.is_pressed('q')):
        ClimbU = 1
    else:
        ClimbU = 0

    if(keyboard.is_pressed('e')):
        HoodD = 1
    else:
        HoodD = 0

    if(keyboard.is_pressed('r')):
        HoodU = 1
    else:
        HoodU = 0

    if(keyboard.is_pressed(']')):
        Restart = 1
        InL = 1
        InR = 1
    else:
        Restart = 0

    if(keyboard.is_pressed('f')):
        ClimbBack = 1
    else:
        ClimbBack = 0

    if(keyboard.is_pressed('h')):
        ClimbForward = 1
    else:
        ClimbForward = 0

    
    #sets hood angle automatically
    if(Dist <= 4.3):
        if abs(HAngle - HAngles[HIndex]) < 30:
            BumperL = 1
        else:
            BumperL = 0
        
        if HAngle > HAngles[HIndex]:
            HoodU = 0
            HoodD = 1
        elif HAngle < HAngles[HIndex]:
            HoodU = 1
            HoodD = 0
    else:
        if abs(HAngle - 32) < 30:
            BumperL = 1
        else:
            BumperL = 0
        if HAngle > 32:
            HoodU = 0
            HoodD = 1
        elif HAngle < 32:
            HoodU = 1
            HoodD = 0
    
    RRot = GRot[1]

    if(keyboard.is_pressed(';')):
        if(HRot < 90):
            HRot += 360
            if RRot < 230:
                RRot += 360
        
        if(HRot > 270):
            if(RRot < 135):
                RRot += 360
        
        pidTurn.setpoint = HRot
        Turn = pidTurn(RRot)\

    if(keyboard.is_pressed('/')):
        if(BRot < 90):
            BRot += 360
            if(RRot < 230):
                RRot += 360
        
        if(BRot > 270):
            if(RRot < 135):
                RRot += 360
        
        pidTurn.setpoint = BRot
        Turn = pidTurn(RRot)

    #if GoToHub == 1:
    #    pass


    #print()
    #print()

    #Writes to the controls text document
    Controls.write('a=' + str(RevIn) + '\nb=' + str(InR) + '\nx=' + str(InL) + '\ny=' + str(Shoot) + '\ndpad_left=' + str(ClimbD) + '\ndpad_right=' + str(ClimbU) + 
    '\ndpad_up=' + str(HoodU) + '\ndpad_down=' + str(HoodD) + '\nbumper_l=' + str(BumperL) + '\nbumper_r=' + str(BumperR) + '\nstop=' + str(Stop) + '\nrestart=' + str(Restart) + 
    '\nright_y='+str(RightY) + '\nright_x=' + str(Turn) + '\nleft_y=' + str(YMov) + '\nleft_x=' + str(XMov) + '\ntrigger_l=' + str(ClimbBack) + '\ntrigger_r=' + str(ClimbForward))

    #Closes the documents
    Robot.close()
    Game.close()
    Controls.close()

    time.sleep(0.05)
 
#cheat sheet
'''
a=0
b=0
x=0
y=0
dpad_left=0
dpad_right=0
bumper_l=0
bumper_r=0
stop=0
restart=0
right_y=0
right_x=0
left_y=0
left_x=0
trigger_l=0
trigger_r=0
'''